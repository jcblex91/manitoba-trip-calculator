<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shibu's App: Multi-Stop Trip Cost Calculator</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the Google Autocomplete dropdown */
        .pac-container {
            /* Ensure the Google Autocomplete dropdown is visible above everything */
            z-index: 10000;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Styling for the loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Styling for the custom toggle switch */
        #round-trip-toggle:checked ~ .block {
            background-color: #3b82ff; /* Blue for ON */
        }
        #round-trip-toggle:checked ~ .dot {
            transform: translateX(100%);
        }
        
        /* Custom CSS to ensure input alignment */
        .input-group {
            display: flex;
            flex-direction: column;
        }

        /* Ensure labels have a consistent height so inputs align */
        .input-label-container {
            min-height: 40px; 
            display: flex;
            align-items: center;
        }

        /* Stop group hover effect for drag-and-drop clarity */
        .stop-group:hover {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); /* blue ring on hover */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex items-start md:items-center justify-center font-sans">

    <div class="w-full max-w-lg bg-white p-6 md:p-8 rounded-xl shadow-2xl space-y-6 mb-8">
        <h1 class="text-3xl font-extrabold text-gray-800 text-center border-b pb-3 mb-4 flex justify-center items-center relative">
            Shibu's App
            <!-- Visit Counter Badge -->
            <span id="visit-counter-badge" class="absolute right-0 top-1/2 -translate-y-1/2 px-2 py-1 text-xs font-semibold bg-indigo-100 text-indigo-700 rounded-full shadow-sm">
                Visits: Loading...
            </span>
        </h1>
        <p class="text-sm text-gray-500 text-center">Calculate distance, time, and fuel cost for multi-stop trips within Manitoba, Canada.</p>

        <!-- Input Section -->
        <div id="input-section" class="space-y-6">
            
            <!-- Fuel Inputs -->
            <div class="grid grid-cols-2 gap-4 pb-4 border-b border-gray-200">
                
                <div class="input-group">
                    <label class="block">
                        <div class="input-label-container">
                            <span class="text-xs sm:text-sm font-medium text-gray-700">Fuel Efficiency (km/L or mi/gal)</span>
                        </div>
                        <input id="fuel-efficiency-input" type="number" min="1" placeholder="e.g., 10" value="10"
                               class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"
                               required>
                    </label>
                </div>

                <div class="input-group">
                    <label class="block">
                         <div class="input-label-container">
                            <span class="text-xs sm:text-sm font-medium text-gray-700">Fuel Price (per L or gal)</span>
                        </div>
                        <input id="fuel-price-input" type="number" min="0.01" step="0.01" placeholder="e.g., 1.50" value="1.50"
                               class="mt-1 block w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"
                               required>
                    </label>
                </div>
            </div>


            <!-- 1. Origin -->
            <div class="space-y-1">
                <span class="text-sm font-medium text-gray-700">1. Start Location (Origin)</span>
                <div class="flex space-x-2">
                    <input id="origin-input" type="text" placeholder="Starting point in Manitoba"
                           class="location-input flex-grow block w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"
                           required>
                    <button id="current-location-button" type="button"
                            class="bg-blue-500 text-white p-2 rounded-lg font-semibold hover:bg-blue-600 transition duration-150 flex items-center justify-center text-sm whitespace-nowrap">
                        <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0l-4.243-4.243a8 8 0 1111.314 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        Current
                    </button>
                </div>
            </div>

            <!-- 2. Pickup Locations -->
            <div class="space-y-3 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                <h2 class="text-lg font-bold text-yellow-800">Pickup Locations (Waypoints before Drop-offs)</h2>
                <div id="pickup-container" class="space-y-4">
                    <!-- Pickups will be added here dynamically -->
                </div>
                <button id="add-pickup-button" type="button"
                        class="w-full text-yellow-600 border border-yellow-600 py-2 rounded-lg font-semibold hover:bg-yellow-100 transition duration-150">
                    + Add Pickup Stop
                </button>
            </div>
            
            <!-- 3. Drop-off Locations -->
            <div class="space-y-3 p-4 bg-green-50 rounded-lg border border-green-200">
                <h2 class="text-lg font-bold text-green-800">Drop-off Locations (Final Drop-off is last in list)</h2>
                <div id="dropoff-container" class="space-y-4">
                    <!-- Drop-offs will be added here dynamically (Default added in JS) -->
                </div>
                <button id="add-dropoff-button" type="button"
                        class="w-full text-green-600 border border-green-600 py-2 rounded-lg font-semibold hover:bg-green-100 transition duration-150">
                    + Add Drop-off Stop
                </button>
            </div>

            <!-- Round Trip Toggle -->
            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg shadow-inner">
                <span class="text-base font-semibold text-gray-700">Calculate Round Trip (Return to Start)?</span>
                <label for="round-trip-toggle" class="flex items-center cursor-pointer">
                    <div class="relative">
                        <input id="round-trip-toggle" type="checkbox" class="sr-only" checked>
                        <div class="block bg-gray-300 w-14 h-8 rounded-full transition duration-300"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition duration-300 shadow-md"></div>
                    </div>
                </label>
            </div>

            <button id="calculate-button"
                    class="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold text-lg hover:bg-blue-700 transition duration-150 shadow-md">
                Calculate Total Trip Cost
            </button>
        </div>

        <!-- Result Section -->
        <div id="result-section" class="hidden mt-6 pt-4 border-t border-gray-200">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Trip Summary</h2>
            <div id="loading-indicator" class="flex justify-center items-center space-x-2 hidden">
                <div class="spinner"></div>
                <p class="text-blue-600">Calculating route and distance...</p>
            </div>

            <div id="summary-content" class="space-y-3">
                <div class="flex justify-between items-center p-3 bg-blue-50 rounded-lg shadow-sm">
                    <span class="font-semibold text-gray-600">Total Distance:</span>
                    <span id="display-distance" class="font-bold text-blue-600">--</span>
                </div>
                <div class="flex justify-between items-center p-3 bg-blue-50 rounded-lg shadow-sm">
                    <span class="font-semibold text-gray-600">Estimated Travel Time:</span>
                    <span id="display-duration" class="font-bold text-blue-600">--</span>
                </div>
                <div class="flex justify-between items-center p-3 bg-green-50 rounded-lg shadow-lg border-2 border-green-400">
                    <span class="font-extrabold text-gray-700 text-lg">Estimated Fuel Cost:</span>
                    <span id="display-cost" class="font-extrabold text-green-700 text-2xl">--</span>
                </div>
            </div>

             <!-- Error/Message Box -->
            <div id="message-box" class="mt-4 p-3 bg-red-100 text-red-700 rounded-lg hidden" role="alert">
                An error occurred. Please check your locations and API key usage.
            </div>
        </div>
    </div>

    <!-- 1. Load the external configuration file (config.js) first -->
    <script src="config.js"></script>
    
    <!-- 2. Firebase SDK Imports for Counter (Now checks config.js first) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, increment, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const visitCounterBadge = document.getElementById('visit-counter-badge');

        // --- Configuration Loading Logic ---
        let firebaseConfig = null;
        let configSource = 'Unknown';
        
        const isConfigJsDefined = typeof FIREBASE_CONFIG !== 'undefined';
        const hasConfigJsApiKey = isConfigJsDefined && FIREBASE_CONFIG.apiKey && FIREBASE_CONFIG.apiKey !== "YOUR_FIREBASE_API_KEY";

        if (hasConfigJsApiKey) {
            // 1. Use the user's config from config.js if it's defined and updated.
            firebaseConfig = FIREBASE_CONFIG;
            configSource = 'config.js (User-Provided)';
        } else if (typeof __firebase_config !== 'undefined') {
            // 2. Fallback to the environment variable config string if user config is missing/placeholder.
            try {
                firebaseConfig = JSON.parse(__firebase_config);
                configSource = 'Runtime Environment (Fallback)';
            } catch (e) {
                console.error("FIREBASE ERROR: Failed to parse __firebase_config environment variable.", e);
            }
        } else {
             console.warn("FIREBASE WARNING: No configuration object found (config.js is missing or unset).");
        }
        
        /**
         * The document reference for the public visit counter.
         * Path: /artifacts/{appId}/public/data/metrics/page_visits
         */
        function getCounterDocRef(db) {
            return doc(db, 
                `artifacts/${appId}/public/data/metrics/`, 
                'page_visits'
            );
        }

        /**
         * Increments the visit counter in Firestore and sets up a listener 
         * to display the real-time count.
         */
        async function incrementAndListen(db) {
            const counterRef = getCounterDocRef(db);
            const counterFieldName = 'count'; 

            try {
                // 1. Increment the counter using setDoc with merge: true 
                await setDoc(counterRef, {
                    [counterFieldName]: increment(1)
                }, { merge: true }); 

                // 2. Set up real-time listener (onSnapshot)
                onSnapshot(counterRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const currentCount = docSnap.data()[counterFieldName] || 0;
                        visitCounterBadge.textContent = `Visits: ${currentCount.toLocaleString()}`;
                        visitCounterBadge.classList.replace('bg-indigo-100', 'bg-green-100');
                    } else {
                        visitCounterBadge.textContent = `Visits: 0`;
                    }
                }, (error) => {
                    console.error("FIREBASE ERROR: Firestore Listener failed.", error);
                    visitCounterBadge.textContent = `Visits: Fail (Listen)`;
                    visitCounterBadge.classList.replace('bg-indigo-100', 'bg-red-100');
                });

            } catch (e) {
                console.error("FIREBASE ERROR: Counter increment operation failed.", e);
                visitCounterBadge.textContent = `Visits: Fail (Update)`;
                visitCounterBadge.classList.replace('bg-indigo-100', 'bg-red-100');
            }
        }

        /**
         * Initializes Firebase, performs authentication, and starts the counter logic.
         */
        async function initializeAppAndCounter() {
            // Wait for DOM to ensure the badge element exists
            await new Promise(resolve => {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', resolve);
                } else {
                    resolve();
                }
            });

            try {
                // --- Final Configuration Check ---
                if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_FIREBASE_API_KEY") {
                    console.error("FIREBASE ERROR: Configuration key missing or is a placeholder. Cannot initialize.");
                    visitCounterBadge.textContent = `Visits: Config Missing`;
                    visitCounterBadge.classList.replace('bg-indigo-100', 'bg-yellow-100');
                    // Prevent further Firebase attempts
                    return; 
                }
                
                // *** DEBUGGING STEP ADDED HERE ***
                console.log(`[DEBUG] Firebase config source: ${configSource}`);
                console.log(`[DEBUG] Attempting to initialize Firebase with Project ID: ${firebaseConfig.projectId}`);
                
                // Initialize App and Services
                const app = initializeApp(firebaseConfig);
                const db = getFirestore(app);
                const auth = getAuth(app);
                
                // Sign in
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                incrementAndListen(db);

            } catch (error) {
                console.error("FIREBASE FATAL ERROR: Initialization or Authentication failed.", error);
                visitCounterBadge.textContent = `Visits: Init Failed`;
                visitCounterBadge.classList.replace('bg-indigo-100', 'bg-red-100');
            }
        }

        initializeAppAndCounter();
    </script>


    <!-- 3. Main Application Script (Google Maps Logic) -->
    <script>
        // Check for required API_KEY constant from config.js
        if (typeof API_KEY === 'undefined') {
            document.addEventListener('DOMContentLoaded', () => {
                const errorBox = document.getElementById('message-box');
                errorBox.classList.remove('hidden');
                errorBox.classList.add('bg-red-200', 'text-red-800');
                errorBox.textContent = "FATAL ERROR: 'API_KEY' not found. Please ensure config.js is loaded correctly and defines const API_KEY.";
            });
        }
        
        // --- DOM Element References ---
        const calculateButton = document.getElementById('calculate-button');
        const addPickupButton = document.getElementById('add-pickup-button');
        const addDropoffButton = document.getElementById('add-dropoff-button');
        const currentLocationButton = document.getElementById('current-location-button');
        const roundTripToggle = document.getElementById('round-trip-toggle'); 
        
        const originInput = document.getElementById('origin-input');
        const pickupContainer = document.getElementById('pickup-container');
        const dropoffContainer = document.getElementById('dropoff-container');

        const fuelEfficiencyInput = document.getElementById('fuel-efficiency-input');
        const fuelPriceInput = document.getElementById('fuel-price-input');

        const resultSection = document.getElementById('result-section');
        const loadingIndicator = document.getElementById('loading-indicator');
        const summaryContent = document.getElementById('summary-content');
        const displayDistance = document.getElementById('display-distance');
        const displayDuration = document.getElementById('display-duration');
        const displayCost = document.getElementById('display-cost');
        const messageBox = document.getElementById('message-box');

        let directionsService;
        let geocoder; 
        let uniqueIdCounter = 0; 
        
        // --- Manitoba Restriction Constants ---
        // Coordinates defining the bounding box for Manitoba, Canada
        const MANITOBA_NE = { lat: 60.0, lng: -88.0 }; 
        const MANITOBA_SW = { lat: 49.0, lng: -102.0 }; 
        const CANADA_RESTRICTION = { country: 'ca' };
        // --- End Restriction Constants ---


        // --- Drag and Drop State and Handlers ---
        let dragSrcEl = null;

        function handleDragStart(e) {
            this.style.opacity = '0.4'; 
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            // Store the stop type to prevent mixing pickup and dropoff lists
            e.dataTransfer.setData('text/plain', this.getAttribute('data-stop-type')); 
        }

        function handleDragEnd(e) {
            this.style.opacity = '1';
            // Clean up any drag styling
            document.querySelectorAll('.stop-group').forEach(item => {
                item.classList.remove('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');
            });
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            const sourceType = dragSrcEl.getAttribute('data-stop-type');
            const targetType = this.getAttribute('data-stop-type');

            // Only highlight if the drag source and target are in the same list type
            if (dragSrcEl !== this && sourceType === targetType) {
                 this.classList.add('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');
        }

        function handleDrop(e) {
            e.stopPropagation();
            
            this.classList.remove('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');

            if (dragSrcEl !== this) {
                const sourceType = dragSrcEl.getAttribute('data-stop-type');
                const targetType = this.getAttribute('data-stop-type');

                if (sourceType === targetType) {
                    // Perform the actual DOM manipulation to reorder the element
                    const targetContainer = this.parentNode;
                    // Insert the dragged element before the element it was dropped on
                    targetContainer.insertBefore(dragSrcEl, this);
                    relabelStops();
                } else {
                    displayMessage(`Cannot move a ${sourceType} stop into the ${targetType} section.`, 'error');
                }
            }
            return false;
        }

        /**
         * Attaches all necessary drag-and-drop event listeners to a stop element.
         */
        function setupDragAndDrop(element) {
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragenter', handleDragEnter);
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('dragleave', handleDragLeave);
            element.addEventListener('drop', handleDrop);
            element.addEventListener('dragend', handleDragEnd);
        }
        // --- End Drag and Drop ---


        /**
         * Clears and displays a temporary message in the message box.
         */
        function displayMessage(text, type = 'error') {
            messageBox.textContent = text;
            messageBox.className = 'mt-4 p-3 rounded-lg hidden'; // Reset classes
            
            if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-700', 'shadow-md');
            } else if (type === 'info') {
                messageBox.classList.add('bg-blue-100', 'text-blue-700');
            }
            messageBox.classList.remove('hidden');

            if (type === 'info') {
                 // Auto-hide info messages after 3 seconds
                 setTimeout(() => messageBox.classList.add('hidden'), 3000);
            }
        }

        /**
         * Initializes Google Maps Autocomplete for a specific input field,
         * restricting searches to Canada and providing a bias towards Manitoba.
         */
        function initializeAutocompleteForInput(inputElement) {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || !inputElement) {
                 return;
            }

            const manitobaBounds = new google.maps.LatLngBounds(MANITOBA_SW, MANITOBA_NE);

            const autocompleteOptions = {
                fields: ["formatted_address", "geometry", "name"],
                strictBounds: false, // Bias towards, but don't strictly restrict to, the bounds
                types: ["geocode", "establishment"],
                componentRestrictions: CANADA_RESTRICTION,
                bounds: manitobaBounds, 
            };

            new google.maps.places.Autocomplete(inputElement, autocompleteOptions);
        }

        /**
         * Master function to initialize Google services after the API script loads.
         * This function is set as the callback for the Google Maps script load.
         */
        window.initAutocomplete = function() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
                 displayMessage("Google Maps API failed to load. Please check your API key.", 'error');
                 return;
            }

            directionsService = new google.maps.DirectionsService();
            geocoder = new google.maps.Geocoder(); 
            
            // Initialize autocomplete for the origin input
            initializeAutocompleteForInput(originInput);
            
            // Initialize autocompletes for any existing dynamic stops (if any)
            document.querySelectorAll('.pickup-input, .dropoff-input').forEach(initializeAutocompleteForInput);
            
            // Ensure there is at least one input for pickup and drop-off to start
            if (pickupContainer.children.length === 0) {
                 addPickup();
            }
            if (dropoffContainer.children.length === 0) {
                 addDropoff();
            }
            
            displayMessage("Google Maps services loaded and location search is biased towards Manitoba, Canada.", 'info');
        }
        
        /**
         * Uses the browser's Geolocation API to find the user's current position
         * and reverse geocode it to set the Origin input value.
         */
        function setCurrentLocation() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || !geocoder) {
                displayMessage("Google Maps services are still loading. Please wait a moment and try again.", 'error');
                return;
            }
            
            if (!navigator.geolocation) {
                displayMessage("Geolocation is not supported by your browser.", 'error');
                return;
            }

            // Show loading state on the button
            currentLocationButton.disabled = true;
            const originalText = currentLocationButton.innerHTML;
            currentLocationButton.innerHTML = `<div class="spinner w-4 h-4 mr-2"></div> Finding...`;

            navigator.geolocation.getCurrentPosition((position) => {
                const latlng = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                };

                // Reverse geocoding to get a readable address
                geocoder.geocode({ location: latlng }, (results, status) => {
                    currentLocationButton.disabled = false;
                    currentLocationButton.innerHTML = originalText;

                    if (status === 'OK' && results[0]) {
                        originInput.value = results[0].formatted_address;
                        displayMessage("Current location set!", 'info');
                    } else {
                        // Fallback to coordinates if reverse geocoding fails
                        originInput.value = `${latlng.lat}, ${latlng.lng}`;
                        displayMessage("Failed to find exact address, using coordinates.", 'info');
                    }
                });
            }, (error) => {
                // Handle geolocation errors
                currentLocationButton.disabled = false;
                currentLocationButton.innerHTML = originalText;

                let errorMessage = "Geolocation failed: ";
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage += "You denied the request for Geolocation.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage += "Location information is unavailable.";
                        break;
                    case error.TIMEOUT:
                        errorMessage += "The request to get user location timed out.";
                        break;
                    default:
                        errorMessage += "An unknown error occurred.";
                        break;
                }
                displayMessage(errorMessage, 'error');
            });
        }


        /**
         * Generic function to add a stop input element to a container.
         */
        function addStop(type, container, placeholder) {
            uniqueIdCounter++;
            const newStopId = `${type}-input-${uniqueIdCounter}`;
            
            const stopDiv = document.createElement('div');
            stopDiv.className = 'flex space-x-2 stop-group p-2 rounded-lg shadow-sm border border-gray-200 cursor-move bg-white transition duration-150 ease-in-out';
            stopDiv.setAttribute('draggable', 'true');
            stopDiv.setAttribute('data-stop-type', type);


            stopDiv.innerHTML = `
                <!-- Drag Handle -->
                <div class="drag-handle text-gray-400 self-center p-1 hover:text-gray-700 transition duration-150 cursor-grab">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </div>
                <label class="block flex-grow">
                    <span class="text-sm font-medium text-gray-700 stop-label"></span>
                    <input id="${newStopId}" type="text" placeholder="${placeholder}"
                           class="${type}-input location-input block w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                </label>
                <button type="button" class="remove-stop-button self-end bg-red-500 text-white p-2 rounded-lg h-[40px] w-[40px] hover:bg-red-600 transition duration-150 flex items-center justify-center text-xl leading-none" aria-label="Remove Stop">
                    &times;
                </button>
            `;

            container.appendChild(stopDiv);
            // Wait for the script to load before trying to init Autocomplete
            if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
                initializeAutocompleteForInput(document.getElementById(newStopId));
            }
            
            relabelStops();
            setupDragAndDrop(stopDiv);

            // Add event listener for removal
            stopDiv.querySelector('.remove-stop-button').addEventListener('click', () => {
                removeStop(stopDiv);
            });
        }

        function addPickup() {
            addStop('pickup', pickupContainer, 'Pickup location in Manitoba');
        }

        function addDropoff() {
            addStop('dropoff', dropoffContainer, 'Drop-off location in Manitoba');
        }

        /**
         * Removes a stop input field and re-labels the remaining ones.
         */
        function removeStop(stopDiv) {
            stopDiv.remove();
            relabelStops();
        }
        
        /**
         * Re-labels all dynamic stops based on their container and position (e.g., Pickup 1, Drop-off 2).
         */
        function relabelStops() {
            const pickupGroups = pickupContainer.querySelectorAll('.stop-group');
            pickupGroups.forEach((group, index) => {
                const labelSpan = group.querySelector('.stop-label');
                if (labelSpan) {
                    labelSpan.textContent = `Pickup ${index + 1}`;
                }
            });

            const dropoffGroups = dropoffContainer.querySelectorAll('.stop-group');
            const totalDropoffs = dropoffGroups.length;

            dropoffGroups.forEach((group, index) => {
                const labelSpan = group.querySelector('.stop-label');
                if (labelSpan) {
                    const isFinal = (index === totalDropoffs - 1);
                    labelSpan.textContent = `Drop-off ${index + 1} ${isFinal ? '(Final Destination)' : ''}`;
                }
            });
        }


        /**
         * Calculates the return trip from the final destination back to the origin,
         * and adds its distance/duration to the running total.
         */
        function calculateReturnTrip(origin, destination, currentDistance, currentDuration, fuelEfficiency, fuelPrice) {
            const returnRequest = {
                origin: destination,
                destination: origin,
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
            };

            directionsService.route(returnRequest, (response, status) => {
                if (status !== 'OK') {
                    loadingIndicator.classList.add('hidden');
                    displayMessage(`Warning: Primary route calculated, but failed to calculate the return trip. Status: ${status}. Showing one-way result.`, 'error');
                    finalizeTripCalculation(currentDistance, currentDuration, fuelEfficiency, fuelPrice);
                    return;
                }

                const returnLegDistance = response.routes[0].legs[0].distance.value;
                const returnLegDuration = response.routes[0].legs[0].duration.value;

                const finalDistance = currentDistance + returnLegDistance;
                const finalDuration = currentDuration + returnLegDuration;

                finalizeTripCalculation(finalDistance, finalDuration, fuelEfficiency, fuelPrice);
            });
        }

        /**
         * Formats and displays the final calculated results.
         */
        function finalizeTripCalculation(totalDistanceMeters, totalDurationSeconds, fuelEfficiency, fuelPrice) {
            loadingIndicator.classList.add('hidden');

            const distanceKm = totalDistanceMeters / 1000;
            const formattedDistance = (distanceKm).toFixed(1) + ' km';
            const formattedDuration = formatDuration(totalDurationSeconds);

            // Calculation: (Distance / Efficiency) * Price = Cost
            const fuelConsumedLiters = distanceKm / fuelEfficiency;
            const totalCost = fuelConsumedLiters * fuelPrice;

            displayDistance.textContent = formattedDistance;
            displayDuration.textContent = formattedDuration;
            displayCost.textContent = `$${totalCost.toFixed(2)}`;

            summaryContent.classList.remove('hidden');
            resultSection.classList.remove('hidden');
        }


        /**
         * Main function to validate inputs, build the route request, and call DirectionsService.
         */
        function calculateTripCost() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || !directionsService) {
                displayMessage("Google Maps services are still loading or failed to initialize. Please wait and try again.", 'error');
                return;
            }

            // Reset UI state
            displayMessage('', 'info'); 
            resultSection.classList.add('hidden');
            summaryContent.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');

            const origin = originInput.value.trim();
            const fuelEfficiency = parseFloat(fuelEfficiencyInput.value);
            const fuelPrice = parseFloat(fuelPriceInput.value);

            // Get valid, non-empty locations from inputs
            const pickupInputs = Array.from(document.querySelectorAll('.pickup-input')).map(input => input.value.trim()).filter(val => val);
            const dropoffInputs = Array.from(document.querySelectorAll('.dropoff-input')).map(input => input.value.trim()).filter(val => val);

            // Input validation
            if (!origin || dropoffInputs.length === 0 || isNaN(fuelEfficiency) || isNaN(fuelPrice) || fuelEfficiency <= 0 || fuelPrice <= 0) {
                displayMessage("Please ensure Start Location, at least one Drop-off, and valid Fuel inputs are provided (values > 0).", 'error');
                loadingIndicator.classList.add('hidden');
                resultSection.classList.remove('hidden');
                return;
            }

            // The last drop-off is the final destination for the one-way trip
            const destination = dropoffInputs[dropoffInputs.length - 1]; 
            const intermediateDropoffs = dropoffInputs.slice(0, -1);
            
            // All intermediate points (pickups + intermediate dropoffs) form the waypoints list
            const allIntermediateStops = [...pickupInputs, ...intermediateDropoffs];

            const waypoints = allIntermediateStops.map(location => ({ 
                location: location,
                stopover: true // Treat these as points you stop at
            }));

            // Google Maps Directions Request
            const request = {
                origin: origin,
                destination: destination,
                waypoints: waypoints,
                optimizeWaypoints: false, // Use the user's order
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
            };

            directionsService.route(request, (response, status) => {

                if (status !== 'OK') {
                    loadingIndicator.classList.add('hidden');
                    let errorMessage = "Could not calculate the route. Status: " + status;
                    if (status === 'ZERO_RESULTS') {
                        errorMessage = "No route found. Please check all locations are valid and accessible (e.g., within Manitoba/Canada).";
                    } else if (status === 'NOT_FOUND') {
                        errorMessage = "One or more locations could not be found. Check spelling and refine addresses.";
                    } else if (status === 'OVER_QUERY_LIMIT') {
                        errorMessage = "API Query Limit exceeded. Please check your Google Maps billing and usage.";
                    }
                    displayMessage(errorMessage, 'error');
                    resultSection.classList.remove('hidden');
                    return;
                }

                let totalDistanceMeters = 0;
                let totalDurationSeconds = 0;

                // Sum up distance and duration for all legs of the route
                response.routes[0].legs.forEach(leg => {
                    totalDistanceMeters += leg.distance.value;
                    totalDurationSeconds += leg.duration.value;
                });

                const isRoundTrip = roundTripToggle.checked;
                
                if (isRoundTrip) {
                    // Calculate return journey if round trip is selected
                    calculateReturnTrip(origin, destination, totalDistanceMeters, totalDurationSeconds, fuelEfficiency, fuelPrice);
                } else {
                    // Finalize calculation for one-way trip
                    finalizeTripCalculation(totalDistanceMeters, totalDurationSeconds, fuelEfficiency, fuelPrice);
                }
            });
        }

        /**
         * Helper function to format duration from seconds to a readable string (e.g., "1 day 5 hr 30 min").
         */
        function formatDuration(seconds) {
            const days = Math.floor(seconds / (3600 * 24));
            seconds -= days * 3600 * 24;
            const hours = Math.floor(seconds / 3600);
            seconds -= hours * 3600;
            const minutes = Math.floor(seconds / 60);

            let parts = [];
            if (days > 0) parts.push(days + ' day' + (days > 1 ? 's' : ''));
            if (hours > 0) parts.push(hours + ' hr');
            if (minutes > 0) parts.push(minutes + ' min');

            return parts.length > 0 ? parts.join(' ') : 'Less than a minute';
        }

        // --- Event listeners ---
        addPickupButton.addEventListener('click', addPickup);
        addDropoffButton.addEventListener('click', addDropoff);
        calculateButton.addEventListener('click', calculateTripCost);
        currentLocationButton.addEventListener('click', setCurrentLocation); 

        // Load Google Maps API script dynamically
        function loadMapsScript() {
            // Check if API_KEY is available from config.js (or globally if executed in a sandbox)
            if (typeof API_KEY === 'undefined' || API_KEY === "YOUR_GOOGLE_MAPS_API_KEY" || API_KEY === "") {
                displayMessage("Google Maps API Key missing or unset in config.js. Please update the key and try reloading.", 'error');
                return;
            }

            const script = document.createElement('script');
            // The callback parameter 'initAutocomplete' must match the function name defined above
            script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places,geometry&callback=initAutocomplete`;
            script.async = true;
            script.onerror = () => {
                displayMessage("Error loading the Google Maps API script. Check your API key or network connection.", 'error');
            };
            document.head.appendChild(script);
        }

        // Start loading the script when the window loads
        window.onload = loadMapsScript;

    </script>
</body>
</html>