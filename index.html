<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shibu's App</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- Liquid Background Animation (Default) --- */
        body {
            /* Default Gradient fallback */
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            background-attachment: fixed; /* Parallax-like effect */
            background-position: center;
            background-repeat: no-repeat;
            min-height: 100vh;
            transition: background-image 0.8s ease-in-out;
            animation: gradientBG 15s ease infinite;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* --- Dynamic Weather Background Images --- */
        body.weather-clear {
            background-image: url('https://images.unsplash.com/photo-1601297183305-6df142704ea2?q=80&w=1920&auto=format&fit=crop');
            background-size: cover;
            animation: none; 
        }
        body.weather-clouds {
            background-image: url('https://images.unsplash.com/photo-1534088568595-a066f410bcda?q=80&w=1920&auto=format&fit=crop');
            background-size: cover;
            animation: none;
        }
        body.weather-rain, body.weather-drizzle {
            background-image: url('https://images.unsplash.com/photo-1515694346937-94d85e41e6f0?q=80&w=1920&auto=format&fit=crop');
            background-size: cover;
            animation: none;
        }
        body.weather-snow {
            background-image: url('https://images.unsplash.com/photo-1477601434689-19eef7b9c6d8?q=80&w=1920&auto=format&fit=crop');
            background-size: cover;
            animation: none;
        }
        body.weather-thunderstorm {
            background-image: url('https://images.unsplash.com/photo-1605727216801-e27ce1d0cc28?q=80&w=1920&auto=format&fit=crop');
            background-size: cover;
            animation: none;
            color: white; /* Ensure text visibility on dark storm backgrounds */
        }
        body.weather-haze, body.weather-mist {
            background-image: url('https://images.unsplash.com/photo-1487621167305-5d248087c724?q=80&w=1920&auto=format&fit=crop');
            background-size: cover;
            animation: none;
        }
        /* --- End Dynamic Weather Themes --- */

        /* --- Liquid Glass Container Styling --- */
        .glass-panel {
            /* Glassmorphism Effect */
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        /* --- Material Theme Input Fields --- */
        .material-input {
            background-color: #ffffff; /* Solid white background */
            border: 1px solid #cbd5e1; /* Slate-300 */
            border-radius: 4px; /* Material standard rounded corners */
            color: #1e293b; /* Slate-800 text */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
            font-size: 1rem;
        }
        .material-input:hover {
            border-color: #64748b; /* Darker border on hover */
        }
        .material-input:focus {
            border-color: #3b82f6; /* Blue-500 on focus */
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Blue focus ring */
            outline: none;
        }
        .material-input::placeholder {
            color: #94a3b8; /* Slate-400 */
        }

        /* Glass Button (Kept as Glass/Material hybrid for consistency) */
        .glass-btn {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .glass-btn:hover {
            background: rgba(255, 255, 255, 0.85);
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Custom styles for the Google Autocomplete dropdown */
        .pac-container {
            z-index: 10000;
            background-color: #ffffff; /* Solid background for dropdown */
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0,0,0,0.06);
            border: 1px solid #e2e8f0;
        }

        /* Styling for the loading spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Styling for the custom toggle switch */
        #round-trip-toggle:checked ~ .block {
            background-color: #3b82ff; /* Blue for ON */
        }
        #round-trip-toggle:checked ~ .dot {
            transform: translateX(100%);
        }
        
        /* Custom CSS to ensure input alignment */
        .input-group {
            display: flex;
            flex-direction: column;
        }

        /* Ensure labels have a consistent height so inputs align */
        .input-label-container {
            min-height: 40px; 
            display: flex;
            align-items: center;
        }

        /* Stop group hover effect for drag-and-drop clarity */
        .stop-group:hover {
            background: rgba(255, 255, 255, 0.4); 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .weather-info {
            min-width: 80px;
            text-align: right;
            font-size: 0.8rem;
            color: #1f2937; /* Darker for glass contrast */
        }

        /* Ensure sufficient padding for the current location icon */
        #origin-input {
            padding-right: 3rem; 
        }
        
        /* Button inside the input must not be part of the flow */
        #current-location-button {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%; /* Match input height */
        }

        /* Styling for the interactive weather button */
        .interactive-weather-btn {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 9999px;
            transition: all 0.2s;
            position: relative; 
            background: rgba(255,255,255,0.3);
        }
        .interactive-weather-btn:hover {
            background-color: rgba(255,255,255,0.6); 
            color: #1d4ed8; 
        }

        /* Custom Tooltip Styling */
        .weather-tooltip {
            position: absolute;
            top: 100%;
            right: 0;
            z-index: 50;
            min-width: 150px;
            background-color: rgba(31, 41, 55, 0.95); /* Nearly solid dark */
            backdrop-filter: blur(4px);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 0.8rem;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
        }

        .interactive-weather-btn:hover .weather-tooltip,
        .interactive-weather-btn.active .weather-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .weather-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            right: 15px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent rgba(31, 41, 55, 0.95) transparent;
        }
        
        /* Override Tailwind text colors for better contrast on glass */
        .text-gray-700 { color: #1f2937; font-weight: 600; }
        .text-gray-600 { color: #374151; font-weight: 500; }
        .text-gray-500 { color: #4b5563; }
        
        /* Main Action Button Gradient */
        #calculate-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            box-shadow: 0 4px 15px 0 rgba(116, 79, 168, 0.55);
        }
        #calculate-button:hover {
             background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex items-start md:items-center justify-center font-sans">

    <!-- Replaced bg-white with glass-panel class -->
    <div class="glass-panel w-full max-w-lg p-6 md:p-8 space-y-6 mb-8">
        <h1 class="text-3xl font-extrabold text-gray-900 text-center border-b border-gray-300/30 pb-3 mb-4 flex justify-center items-center relative">
            Shibu's App
            <!-- Visit Counter Badge -->
            <span id="visit-counter-badge" class="absolute right-0 top-1/2 -translate-y-1/2 px-2 py-1 text-xs font-semibold bg-white/50 text-indigo-900 rounded-full shadow-sm backdrop-blur-sm">
                Visits: Loading...
            </span>
        </h1>

        <!-- Input Section -->
        <div id="input-section" class="space-y-6">
            
            <!-- Fuel Inputs -->
            <div class="grid grid-cols-2 gap-4 pb-4 border-b border-gray-300/30">
                
                <div class="input-group">
                    <label class="block">
                        <div class="input-label-container">
                            <span class="text-xs sm:text-sm text-gray-800">Fuel Efficiency (km/L or mi/gal)</span>
                        </div>
                        <!-- Updated to material-input -->
                        <input id="fuel-efficiency-input" type="number" min="1" placeholder="e.g., 10" value="10"
                               class="material-input block w-full px-4 py-2 rounded-lg shadow-sm"
                               required>
                    </label>
                </div>

                <div class="input-group">
                    <label class="block">
                         <div class="input-label-container">
                            <span class="text-xs sm:text-sm text-gray-800">Fuel Price (per L or gal)</span>
                        </div>
                        <!-- Updated to material-input -->
                        <input id="fuel-price-input" type="number" min="0.01" step="0.01" placeholder="e.g., 1.50" value="1.50"
                               class="material-input block w-full px-4 py-2 rounded-lg shadow-sm"
                               required>
                    </label>
                </div>
            </div>


            <!-- 1. Origin -->
            <div class="space-y-1">
                <span class="text-sm text-gray-800 flex justify-between items-center">
                    1. Start Location (Origin)
                    <!-- Interactive Weather Button with Tooltip -->
                    <button id="weather-origin-details" class="interactive-weather-btn text-gray-800 flex items-center space-x-1" 
                            title="Hover or Click for current weather">
                        <span>N/A</span>
                        <!-- Tooltip Container -->
                        <div id="weather-tooltip" class="weather-tooltip">
                            <p id="tooltip-content">Loading weather status...</p>
                        </div>
                    </button>
                </span>
                <div class="relative"> 
                    <!-- Updated to material-input -->
                    <input id="origin-input" type="text" placeholder="Starting point in Manitoba"
                           class="material-input block w-full px-4 py-2 rounded-lg shadow-sm"
                           required>
                    
                    <!-- Current Location Button -->
                    <button id="current-location-button" type="button" title="Use Current Location"
                            class="absolute inset-y-0 right-0 p-2 flex items-center justify-center text-blue-700 hover:text-blue-900 transition duration-150 rounded-r-lg"
                            style="background-color: transparent;">
                        <!-- Crosshair Icon SVG -->
                        <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="22" y1="12" x2="18" y2="12"></line>
                            <line x1="6" y1="12" x2="2" y2="12"></line>
                            <line x1="12" y1="6" x2="12" y2="2"></line>
                            <line x1="12" y1="22" x2="12" y2="18"></line>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 2. Pickup Locations -->
            <div class="space-y-3 p-4 bg-yellow-100/40 rounded-lg border border-yellow-200/50 backdrop-blur-sm">
                <h2 class="text-lg font-bold text-yellow-900">Pickup Locations (Waypoints)</h2>
                <div id="pickup-container" class="space-y-4">
                    <!-- Pickups will be added here dynamically -->
                </div>
                <button id="add-pickup-button" type="button"
                        class="glass-btn w-full text-yellow-900 border border-yellow-600/30 py-2 rounded-lg font-semibold">
                    + Add Pickup Stop
                </button>
            </div>
            
            <!-- 3. Drop-off Locations -->
            <div class="space-y-3 p-4 bg-green-100/40 rounded-lg border border-green-200/50 backdrop-blur-sm">
                <h2 class="text-lg font-bold text-green-900">Drop-off Locations (Final)</h2>
                <div id="dropoff-container" class="space-y-4">
                    <!-- Drop-offs will be added here dynamically (Default added in JS) -->
                </div>
                <button id="add-dropoff-button" type="button"
                        class="glass-btn w-full text-green-900 border border-green-600/30 py-2 rounded-lg font-semibold">
                    + Add Drop-off Stop
                </button>
            </div>

            <!-- Round Trip Toggle -->
            <div class="flex items-center justify-between p-3 bg-white/30 rounded-lg shadow-sm border border-white/20">
                <span class="text-base font-semibold text-gray-800">Calculate Round Trip?</span>
                <label for="round-trip-toggle" class="flex items-center cursor-pointer">
                    <div class="relative">
                        <input id="round-trip-toggle" type="checkbox" class="sr-only" checked>
                        <div class="block bg-gray-400 w-14 h-8 rounded-full transition duration-300"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition duration-300 shadow-md"></div>
                    </div>
                </label>
            </div>

            <button id="calculate-button"
                    class="w-full text-white py-3 rounded-lg font-bold text-lg shadow-lg transform transition hover:scale-[1.02]">
                Calculate Total Trip Cost
            </button>
        </div>

        <!-- Result Section -->
        <div id="result-section" class="hidden mt-6 pt-4 border-t border-gray-300/30">
            <h2 class="text-xl font-bold text-gray-900 mb-4 text-center">Trip Summary</h2>
            <div id="loading-indicator" class="flex justify-center items-center space-x-2 hidden">
                <div class="spinner"></div>
                <p class="text-white font-semibold shadow-black drop-shadow-md">Calculating route...</p>
            </div>

            <div id="summary-content" class="space-y-3">
                <!-- NEW: Distance to First Stop -->
                <div class="flex justify-between items-center p-3 bg-indigo-100/60 rounded-lg shadow-sm border border-indigo-200 backdrop-blur-sm">
                    <span class="font-semibold text-indigo-900">Distance to First Stop:</span>
                    <span id="display-first-stop-distance" class="font-bold text-indigo-800">--</span>
                </div>
                
                <div class="flex justify-between items-center p-3 bg-blue-100/60 rounded-lg shadow-sm border border-blue-200 backdrop-blur-sm">
                    <span class="font-semibold text-blue-900">Total Distance:</span>
                    <span id="display-distance" class="font-bold text-blue-800">--</span>
                </div>
                <div class="flex justify-between items-center p-3 bg-blue-100/60 rounded-lg shadow-sm border border-blue-200 backdrop-blur-sm">
                    <span class="font-semibold text-blue-900">Estimated Travel Time:</span>
                    <span id="display-duration" class="font-bold text-blue-800">--</span>
                </div>
                <div class="flex justify-between items-center p-3 bg-green-100/70 rounded-lg shadow-lg border border-green-300 backdrop-blur-sm">
                    <span class="font-extrabold text-green-900 text-lg">Estimated Fuel Cost:</span>
                    <span id="display-cost" class="font-extrabold text-green-800 text-2xl">--</span>
                </div>
            </div>

             <!-- Error/Message Box -->
            <div id="message-box" class="mt-4 p-3 bg-red-100/80 text-red-800 rounded-lg hidden border border-red-200" role="alert">
                An error occurred. Please check your locations and API key usage.
            </div>
        </div>
    </div>

    <!-- 1. Load the external configuration file (config.js) first -->
    <script src="config.js"></script>
    
    <!-- 2. Firebase SDK Imports for Counter (Now checks config.js first) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, increment, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const visitCounterBadge = document.getElementById('visit-counter-badge');

        // --- Configuration Loading Logic ---
        let firebaseConfig = null;
        let configSource = 'Unknown';
        
        const isConfigJsDefined = typeof FIREBASE_CONFIG !== 'undefined';
        const hasConfigJsApiKey = isConfigJsDefined && FIREBASE_CONFIG.apiKey && FIREBASE_CONFIG.apiKey !== "YOUR_FIREBASE_API_KEY";

        if (hasConfigJsApiKey) {
            // 1. Use the user's config from config.js if it's defined and updated.
            firebaseConfig = FIREBASE_CONFIG;
            configSource = 'config.js (User-Provided)';
        } else if (typeof __firebase_config !== 'undefined') {
            // 2. Fallback to the environment variable config string if user config is missing/placeholder.
            try {
                firebaseConfig = JSON.parse(__firebase_config);
                configSource = 'Runtime Environment (Fallback)';
            } catch (e) {
                console.error("FIREBASE ERROR: Failed to parse __firebase_config environment variable.", e);
            }
        } else {
             console.warn("FIREBASE WARNING: No configuration object found (config.js is missing or unset).");
        }
        
        /**
         * The document reference for the public visit counter.
         * Path: /artifacts/{appId}/public/data/metrics/page_visits
         */
        function getCounterDocRef(db) {
            return doc(db, 
                `artifacts/${appId}/public/data/metrics/`, 
                'page_visits'
            );
        }

        /**
         * Increments the visit counter in Firestore and sets up a listener 
         * to display the real-time count.
         */
        async function incrementAndListen(db) {
            const counterRef = getCounterDocRef(db);
            const counterFieldName = 'count'; 

            try {
                // 1. Increment the counter using setDoc with merge: true 
                await setDoc(counterRef, {
                    [counterFieldName]: increment(1)
                }, { merge: true }); 

                // 2. Set up real-time listener (onSnapshot)
                onSnapshot(counterRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const currentCount = docSnap.data()[counterFieldName] || 0;
                        visitCounterBadge.textContent = `Visits: ${currentCount.toLocaleString()}`;
                        // Updated for glass theme compatibility
                        visitCounterBadge.classList.remove('bg-white/50', 'text-indigo-900');
                        visitCounterBadge.classList.add('bg-green-100/60', 'text-green-900');
                    } else {
                        visitCounterBadge.textContent = `Visits: 0`;
                    }
                }, (error) => {
                    console.error("FIREBASE ERROR: Firestore Listener failed.", error);
                    visitCounterBadge.textContent = `Visits: Fail (Listen)`;
                    visitCounterBadge.classList.replace('bg-white/50', 'bg-red-100/60');
                });

            } catch (e) {
                console.error("FIREBASE ERROR: Counter increment operation failed.", e);
                visitCounterBadge.textContent = `Visits: Fail (Update)`;
                visitCounterBadge.classList.replace('bg-white/50', 'bg-red-100/60');
            }
        }

        /**
         * Initializes Firebase, performs authentication, and starts the counter logic.
         */
        async function initializeAppAndCounter() {
            // Wait for DOM to ensure the badge element exists
            await new Promise(resolve => {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', resolve);
                } else {
                    resolve();
                }
            });

            try {
                // --- Final Configuration Check ---
                if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_FIREBASE_API_KEY") {
                    console.error("FIREBASE ERROR: Configuration key missing or is a placeholder. Cannot initialize.");
                    visitCounterBadge.textContent = `Visits: Config Missing`;
                    visitCounterBadge.classList.replace('bg-white/50', 'bg-yellow-100/60');
                    // Prevent further Firebase attempts
                    return; 
                }
                
                // Initialize App and Services
                const app = initializeApp(firebaseConfig);
                const db = getFirestore(app);
                const auth = getAuth(app);
                
                // Sign in
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                incrementAndListen(db);

            } catch (error) {
                console.error("FIREBASE FATAL ERROR: Initialization or Authentication failed.", error);
                visitCounterBadge.textContent = `Visits: Init Failed`;
                visitCounterBadge.classList.replace('bg-white/50', 'bg-red-100/60');
            }
        }

        initializeAppAndCounter();
    </script>


    <!-- 3. Main Application Script (Google Maps & Weather Logic) -->
    <script>
        // Check for required API_KEY constant from config.js
        if (typeof API_KEY === 'undefined') {
            document.addEventListener('DOMContentLoaded', () => {
                const errorBox = document.getElementById('message-box');
                errorBox.classList.remove('hidden');
                errorBox.classList.add('bg-red-200', 'text-red-800');
                errorBox.textContent = "FATAL ERROR: 'API_KEY' not found. Please ensure config.js is loaded correctly and defines const API_KEY.";
            });
        }

        // Check for WEATHER_API_KEY constant from config.js
        if (typeof WEATHER_API_KEY === 'undefined' || WEATHER_API_KEY === "YOUR_OPENWEATHERMAP_API_KEY") {
            console.warn("OpenWeatherMap API Key is missing or unset. Basic weather icon/temp features will be limited or unavailable.");
        }
        
        // --- DOM Element References ---
        const calculateButton = document.getElementById('calculate-button');
        const addPickupButton = document.getElementById('add-pickup-button');
        const addDropoffButton = document.getElementById('add-dropoff-button');
        // Updated reference: Now points to the icon button inside the input group
        const currentLocationButton = document.getElementById('current-location-button'); 
        const roundTripToggle = document.getElementById('round-trip-toggle'); 
        
        const originInput = document.getElementById('origin-input');
        const pickupContainer = document.getElementById('pickup-container');
        const dropoffContainer = document.getElementById('dropoff-container');
        const weatherOriginDetails = document.getElementById('weather-origin-details');
        const weatherTooltip = document.getElementById('weather-tooltip');
        const tooltipContent = document.getElementById('tooltip-content');


        const fuelEfficiencyInput = document.getElementById('fuel-efficiency-input');
        const fuelPriceInput = document.getElementById('fuel-price-input');

        const resultSection = document.getElementById('result-section');
        const loadingIndicator = document.getElementById('loading-indicator');
        const summaryContent = document.getElementById('summary-content');
        const displayFirstStopDistance = document.getElementById('display-first-stop-distance'); // NEW REF
        const displayDistance = document.getElementById('display-distance');
        const displayDuration = document.getElementById('display-duration');
        const displayCost = document.getElementById('display-cost');
        const messageBox = document.getElementById('message-box');

        let directionsService;
        let geocoder; 
        let uniqueIdCounter = 0; 
        
        // --- Manitoba Restriction Constants ---
        const MANITOBA_NE = { lat: 60.0, lng: -88.0 }; 
        const MANITOBA_SW = { lat: 49.0, lng: -102.0 }; 
        const CANADA_RESTRICTION = { country: 'ca' };
        // --- End Restriction Constants ---
        
        /**
         * Clears and displays a temporary message in the message box.
         */
        function displayMessage(text, type = 'error') {
            messageBox.textContent = text;
            messageBox.className = 'mt-4 p-3 rounded-lg hidden border border-red-200'; // Reset classes
            
            if (type === 'error') {
                messageBox.classList.add('bg-red-100/80', 'text-red-800', 'shadow-md');
            } else if (type === 'info') {
                messageBox.classList.add('bg-blue-100/80', 'text-blue-800');
            }
            messageBox.classList.remove('hidden');

            if (type === 'info') {
                 // Auto-hide info messages after 3 seconds
                 setTimeout(() => messageBox.classList.add('hidden'), 3000);
            }
        }
        
        /**
         * Applies a dynamic theme class to the body based on the weather condition.
         */
        function applyWeatherTheme(condition) {
            const body = document.body;
            
            // 1. Remove all existing weather theme classes
            const themes = ['weather-clear', 'weather-clouds', 'weather-rain', 'weather-snow', 'weather-thunderstorm', 'weather-haze', 'weather-mist'];
            themes.forEach(theme => body.classList.remove(theme));

            // 2. Map condition string to CSS class
            const normalizedCondition = condition.toLowerCase();

            if (normalizedCondition.includes('clear')) {
                body.classList.add('weather-clear');
            } else if (normalizedCondition.includes('cloud')) {
                body.classList.add('weather-clouds');
            } else if (normalizedCondition.includes('rain') || normalizedCondition.includes('drizzle')) {
                body.classList.add('weather-rain');
            } else if (normalizedCondition.includes('snow')) {
                body.classList.add('weather-snow');
            } else if (normalizedCondition.includes('thunderstorm')) {
                body.classList.add('weather-thunderstorm');
            } else if (normalizedCondition.includes('haze')) {
                body.classList.add('weather-haze');
            } else if (normalizedCondition.includes('mist')) {
                body.classList.add('weather-mist');
            }
            // If no match, it keeps the default gradient
        }

        /**
         * Fetches basic weather data for a given location string and updates the interactive button.
         * The function first geocodes the address to get coordinates.
         */
        async function fetchWeather(location, displayElement, isOrigin = false) {
            
            // Check if API key is valid
            if (typeof WEATHER_API_KEY === 'undefined' || WEATHER_API_KEY === "YOUR_OPENWEATHERMAP_API_KEY") {
                displayElement.innerHTML = `<span>N/A</span>`;
                if (isOrigin) {
                    tooltipContent.textContent = "Weather API Key is missing or invalid. Cannot fetch live data.";
                }
                return;
            }
            
            if (!location || !geocoder) return;

            displayElement.innerHTML = `<div class="spinner w-3 h-3"></div>`;
            displayElement.disabled = true;
            if (isOrigin) {
                tooltipContent.textContent = "Fetching location coordinates...";
            }

            try {
                // 1. Geocode the address to get Lat/Lng
                const geoResult = await new Promise((resolve, reject) => {
                    geocoder.geocode({ address: location }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            resolve(results[0].geometry.location);
                        } else {
                            reject(new Error(`Geocoding failed for ${location}: ${status}`));
                        }
                    });
                });

                const lat = geoResult.lat();
                const lon = geoResult.lng();
                if (isOrigin) {
                    tooltipContent.textContent = "Fetching weather data...";
                }


                // 2. Fetch current weather from OpenWeatherMap
                const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${WEATHER_API_KEY}`;
                
                const response = await fetch(weatherUrl);
                if (!response.ok) {
                    throw new Error(`Weather API returned status ${response.status}`);
                }
                const data = await response.json();
                
                displayElement.disabled = false;

                // 3. Update the display element and tooltip
                if (data.main && data.weather && data.weather.length > 0) {
                    const temp = Math.round(data.main.temp);
                    const iconCode = data.weather[0].icon;
                    const description = data.weather[0].description;
                    const mainCondition = data.weather[0].main;
                    const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
                    
                    const weatherHtml = `
                        <img src="${iconUrl}" alt="${mainCondition}" class="w-6 h-6 inline-block -my-1" 
                            onerror="this.onerror=null;this.src='https://placehold.co/24x24/cccccc/333333?text=W'">
                        <span>${temp}°C</span>
                    `;

                    displayElement.innerHTML = weatherHtml;

                    if (isOrigin) {
                        tooltipContent.innerHTML = `
                            <strong>${mainCondition}</strong><br>
                            ${description.charAt(0).toUpperCase() + description.slice(1)}<br>
                            Temp: ${temp}°C | Wind: ${Math.round(data.wind.speed * 3.6)} km/h
                        `;
                        // --- Apply theme based on Origin weather ---
                        applyWeatherTheme(mainCondition);
                    }
                    
                } else {
                    throw new Error("Invalid weather data structure.");
                }

            } catch (error) {
                console.error("Basic weather fetch error:", error);
                displayElement.disabled = false;
                displayElement.innerHTML = `<span>N/A</span>`;
                if (isOrigin) {
                    tooltipContent.textContent = "Failed to load weather details. Check console for errors.";
                }
            }
        }


        /**
         * Initializes Google Maps Autocomplete for a specific input field,
         * restricting searches to Canada and providing a bias towards Manitoba.
         */
        function initializeAutocompleteForInput(inputElement, isOrigin = false, weatherDisplayElement = null) {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || !inputElement) {
                 return;
            }

            const manitobaBounds = new google.maps.LatLngBounds(MANITOBA_SW, MANITOBA_NE);

            const autocompleteOptions = {
                fields: ["formatted_address", "geometry", "name"],
                strictBounds: false, // Bias towards, but don't strictly restrict to, the bounds
                types: ["geocode", "establishment"],
                componentRestrictions: CANADA_RESTRICTION,
                bounds: manitobaBounds, 
            };

            const autocomplete = new google.maps.places.Autocomplete(inputElement, autocompleteOptions);

            // Fetch weather when the user finishes entering the address (blur event)
            inputElement.addEventListener('blur', () => {
                const locationValue = inputElement.value.trim();
                if (locationValue && weatherDisplayElement) {
                    // Pass isOrigin=true if initializing for the origin input
                    fetchWeather(locationValue, weatherDisplayElement, isOrigin); 
                }
            });
            
            // Initial weather fetch on load if the input has a value
            if (inputElement.value.trim() && weatherDisplayElement) {
                // Pass isOrigin=true if initializing for the origin input
                fetchWeather(inputElement.value, weatherDisplayElement, isOrigin); 
            }
        }

        /**
         * Master function to initialize Google services after the API script loads.
         * This function is set as the callback for the Google Maps script load.
         */
        window.initAutocomplete = function() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
                 displayMessage("Google Maps API failed to load. Please check your API key.", 'error');
                 return;
            }

            directionsService = new google.maps.DirectionsService();
            geocoder = new google.maps.Geocoder(); 
            
            // Initialize autocomplete for the origin input
            initializeAutocompleteForInput(originInput, true, weatherOriginDetails);
            
            // Initialize autocompletes for any existing dynamic stops (if any)
            document.querySelectorAll('.stop-group').forEach(group => {
                const input = group.querySelector('.location-input');
                const weatherSpan = group.querySelector('.weather-info');
                // Pass 'false' for all stop waypoints
                initializeAutocompleteForInput(input, false, weatherSpan); 
            });
            
            // Ensure there is at least one input for pickup and drop-off to start
            if (pickupContainer.children.length === 0) {
                 addPickup();
            }
            if (dropoffContainer.children.length === 0) {
                 addDropoff();
            }
            
            displayMessage("Google Maps services loaded and location search is biased towards Manitoba, Canada.", 'info');
        }
        
        /**
         * Uses the browser's Geolocation API to find the user's current position
         * and reverse geocode it to set the Origin input value.
         */
        function setCurrentLocation() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || !geocoder) {
                displayMessage("Google Maps services are still loading. Please wait a moment and try again.", 'error');
                return;
            }
            
            if (!navigator.geolocation) {
                displayMessage("Geolocation is not supported by your browser.", 'error');
                return;
            }

            // Show loading state on the button
            currentLocationButton.disabled = true;
            // Spinner inside icon area
            currentLocationButton.innerHTML = `<div class="spinner w-4 h-4 text-blue-800"></div>`; 

            navigator.geolocation.getCurrentPosition((position) => {
                const latlng = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                };

                // Reverse geocoding to get a readable address
                geocoder.geocode({ location: latlng }, (results, status) => {
                    currentLocationButton.disabled = false;
                    // Restore original icon state (Crosshair)
                    currentLocationButton.innerHTML = `<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>`;

                    if (status === 'OK' && results[0]) {
                        originInput.value = results[0].formatted_address;
                        displayMessage("Current location set!", 'info');
                        // Fetch weather for the new location and apply theme (isOrigin=true)
                        fetchWeather(originInput.value, weatherOriginDetails, true);
                    } else {
                        // Fallback to coordinates if reverse geocoding fails
                        originInput.value = `${latlng.lat}, ${latlng.lng}`;
                        displayMessage("Failed to find exact address, using coordinates.", 'info');
                    }
                });
            }, (error) => {
                // Handle geolocation errors
                currentLocationButton.disabled = false;
                // Restore original icon state (Crosshair)
                currentLocationButton.innerHTML = `<svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>`;

                let errorMessage = "Geolocation failed: ";
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage += "You denied the request for Geolocation.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage += "Location information is unavailable.";
                        break;
                    case error.TIMEOUT:
                        errorMessage += "The request to get user location timed out.";
                        break;
                    default:
                        errorMessage += "An unknown error occurred.";
                        break;
                }
                displayMessage(errorMessage, 'error');
            });
        }


        /**
         * Generic function to add a stop input element to a container.
         */
        function addStop(type, container, placeholder) {
            uniqueIdCounter++;
            const newStopId = `${type}-input-${uniqueIdCounter}`;
            
            const stopDiv = document.createElement('div');
            // Added padding-t-4 for spacing the weather info from the stop label above it
            stopDiv.className = 'flex space-x-2 stop-group p-2 rounded-lg shadow-sm border border-gray-200 cursor-move bg-white transition duration-150 ease-in-out';
            stopDiv.setAttribute('draggable', 'true');
            stopDiv.setAttribute('data-stop-type', type);


            stopDiv.innerHTML = `
                <!-- Drag Handle -->
                <div class="drag-handle text-gray-400 self-center p-1 hover:text-gray-700 transition duration-150 cursor-grab">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </div>
                <label class="block flex-grow">
                    <span class="text-sm font-medium text-gray-700 stop-label flex justify-between items-center">
                        <!-- Label text is set by relabelStops -->
                        <span class="label-text"></span>
                        <span class="weather-info">N/A</span>
                    </span>
                    <input id="${newStopId}" type="text" placeholder="${placeholder}"
                           class="${type}-input location-input glass-input block w-full px-4 py-2 rounded-lg shadow-sm">
                </label>
                <button type="button" class="remove-stop-button self-end bg-red-500 text-white p-2 rounded-lg h-[40px] w-[40px] hover:bg-red-600 transition duration-150 flex items-center justify-center text-xl leading-none" aria-label="Remove Stop">
                    &times;
                </button>
            `;

            container.appendChild(stopDiv);
            
            // Get references to the dynamically created elements
            const inputElement = document.getElementById(newStopId);
            const weatherSpan = stopDiv.querySelector('.weather-info');

            // Wait for the script to load before trying to init Autocomplete
            if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
                // Pass 'false' for all stop waypoints
                initializeAutocompleteForInput(inputElement, false, weatherSpan);
            }
            
            relabelStops();
            setupDragAndDrop(stopDiv);

            // Add event listener for removal
            stopDiv.querySelector('.remove-stop-button').addEventListener('click', () => {
                removeStop(stopDiv);
            });
        }

        function addPickup() {
            addStop('pickup', pickupContainer, 'Pickup location in Manitoba');
        }

        function addDropoff() {
            addStop('dropoff', dropoffContainer, 'Drop-off location in Manitoba');
        }

        /**
         * Removes a stop input field and re-labels the remaining ones.
         */
        function removeStop(stopDiv) {
            stopDiv.remove();
            relabelStops();
        }
        
        /**
         * Re-labels all dynamic stops based on their container and position (e.g., Pickup 1, Drop-off 2).
         */
        function relabelStops() {
            const pickupGroups = pickupContainer.querySelectorAll('.stop-group');
            pickupGroups.forEach((group, index) => {
                const labelSpan = group.querySelector('.label-text');
                if (labelSpan) {
                    labelSpan.textContent = `Pickup ${index + 1}`;
                }
            });

            const dropoffGroups = dropoffContainer.querySelectorAll('.stop-group');
            const totalDropoffs = dropoffGroups.length;

            dropoffGroups.forEach((group, index) => {
                const labelSpan = group.querySelector('.label-text');
                if (labelSpan) {
                    const isFinal = (index === totalDropoffs - 1);
                    labelSpan.textContent = `Drop-off ${index + 1} ${isFinal ? '(Final Destination)' : ''}`;
                }
            });
        }

        // --- Drag and Drop State and Handlers ---
        let dragSrcEl = null;

        function handleDragStart(e) {
            this.style.opacity = '0.4'; 
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.getAttribute('data-stop-type')); 
        }

        function handleDragEnd(e) {
            this.style.opacity = '1';
            document.querySelectorAll('.stop-group').forEach(item => {
                item.classList.remove('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');
            });
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            const sourceType = dragSrcEl.getAttribute('data-stop-type');
            const targetType = this.getAttribute('data-stop-type');

            if (dragSrcEl !== this && sourceType === targetType) {
                 this.classList.add('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');
        }

        function handleDrop(e) {
            e.stopPropagation();
            
            this.classList.remove('border-blue-400', 'border-2', 'border-dashed', 'bg-blue-50');

            if (dragSrcEl !== this) {
                const sourceType = dragSrcEl.getAttribute('data-stop-type');
                const targetType = this.getAttribute('data-stop-type');

                if (sourceType === targetType) {
                    const targetContainer = this.parentNode;
                    targetContainer.insertBefore(dragSrcEl, this);
                    relabelStops();
                } else {
                    displayMessage(`Cannot move a ${sourceType} stop into the ${targetType} section.`, 'error');
                }
            }
            return false;
        }

        function setupDragAndDrop(element) {
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragenter', handleDragEnter);
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('dragleave', handleDragLeave);
            element.addEventListener('drop', handleDrop);
            element.addEventListener('dragend', handleDragEnd);
        }
        // --- End Drag and Drop ---


        /**
         * Calculates the return trip from the final destination back to the origin,
         * and adds its distance/duration to the running total.
         */
        function calculateReturnTrip(origin, destination, currentDistance, currentDuration, fuelEfficiency, fuelPrice, distanceToFirstStopMeters) {
            const returnRequest = {
                origin: destination,
                destination: origin,
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
            };

            directionsService.route(returnRequest, (response, status) => {
                if (status !== 'OK') {
                    loadingIndicator.classList.add('hidden');
                    displayMessage(`Warning: Primary route calculated, but failed to calculate the return trip. Status: ${status}. Showing one-way result.`, 'error');
                    // Still finalize the calculation using the one-way distance/duration
                    finalizeTripCalculation(currentDistance, currentDuration, fuelEfficiency, fuelPrice, distanceToFirstStopMeters);
                    return;
                }

                const returnLegDistance = response.routes[0].legs[0].distance.value;
                const returnLegDuration = response.routes[0].legs[0].duration.value;

                const finalDistance = currentDistance + returnLegDistance;
                const finalDuration = currentDuration + returnLegDuration;

                finalizeTripCalculation(finalDistance, finalDuration, fuelEfficiency, fuelPrice, distanceToFirstStopMeters);
            });
        }

        /**
         * Formats and displays the final calculated results.
         */
        function finalizeTripCalculation(totalDistanceMeters, totalDurationSeconds, fuelEfficiency, fuelPrice, distanceToFirstStopMeters) {
            loadingIndicator.classList.add('hidden');

            const distanceKm = totalDistanceMeters / 1000;
            const distanceToFirstStopKm = distanceToFirstStopMeters / 1000;
            
            const formattedTotalDistance = (distanceKm).toFixed(1) + ' km';
            const formattedFirstStopDistance = (distanceToFirstStopKm).toFixed(1) + ' km';
            const formattedDuration = formatDuration(totalDurationSeconds);

            // Calculation: (Distance / Efficiency) * Price = Cost
            const fuelConsumedLiters = distanceKm / fuelEfficiency;
            // FIX: Correctly initialize totalCost using the calculated consumption and price
            const totalCost = fuelConsumedLiters * fuelPrice;

            displayFirstStopDistance.textContent = formattedFirstStopDistance; // NEW DISPLAY
            displayDistance.textContent = formattedTotalDistance;
            displayDuration.textContent = formattedDuration;
            displayCost.textContent = `$${totalCost.toFixed(2)}`; // Use the calculated totalCost here

            summaryContent.classList.remove('hidden');
            resultSection.classList.remove('hidden');
        }
        
        /**
         * Calculates the distance from the origin to the first actual stop.
         */
        function calculateDistanceToFirstStop(origin, firstStopLocation, callback) {
            const request = {
                origin: origin,
                destination: firstStopLocation,
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
            };

            directionsService.route(request, (response, status) => {
                if (status === 'OK') {
                    const distanceMeters = response.routes[0].legs[0].distance.value;
                    callback(distanceMeters);
                } else {
                    console.error("Failed to calculate distance to first stop. Status: " + status);
                    callback(0); // Pass 0 if calculation fails
                }
            });
        }


        /**
         * Main function to validate inputs, build the route request, and call DirectionsService.
         */
        function calculateTripCost() {
            if (typeof google === 'undefined' || typeof google.maps === 'undefined' || !directionsService) {
                displayMessage("Google Maps services are still loading or failed to initialize. Please wait and try again.", 'error');
                return;
            }

            // Reset UI state
            displayMessage('', 'info'); 
            resultSection.classList.add('hidden');
            summaryContent.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');

            const origin = originInput.value.trim();
            const fuelEfficiency = parseFloat(fuelEfficiencyInput.value);
            const fuelPrice = parseFloat(fuelPriceInput.value);

            // Get valid, non-empty locations from inputs
            const pickupInputs = Array.from(document.querySelectorAll('.pickup-input')).map(input => input.value.trim()).filter(val => val);
            const dropoffInputs = Array.from(document.querySelectorAll('.dropoff-input')).map(input => input.value.trim()).filter(val => val);
            
            const allStopLocations = [...pickupInputs, ...dropoffInputs];

            // Input validation
            if (!origin || allStopLocations.length === 0 || isNaN(fuelEfficiency) || isNaN(fuelPrice) || fuelEfficiency <= 0 || fuelPrice <= 0) {
                displayMessage("Please ensure Start Location, at least one Stop, and valid Fuel inputs are provided (values > 0).", 'error');
                loadingIndicator.classList.add('hidden');
                resultSection.classList.remove('hidden');
                return;
            }

            const destination = allStopLocations[allStopLocations.length - 1]; 
            const intermediateWaypoints = allStopLocations.slice(0, -1);
            const firstStopLocation = allStopLocations[0]; // The location for the new metric

            const waypoints = intermediateWaypoints.map(location => ({ 
                location: location,
                stopover: true 
            }));

            let distanceToFirstStopMeters = 0;

            // 1. Calculate Distance to First Stop (Async call)
            calculateDistanceToFirstStop(origin, firstStopLocation, (distance) => {
                distanceToFirstStopMeters = distance;
                
                // 2. Calculate Full Trip (Async call, inside the callback)
                const fullTripRequest = {
                    origin: origin,
                    destination: destination,
                    waypoints: waypoints,
                    optimizeWaypoints: false, 
                    travelMode: google.maps.TravelMode.DRIVING,
                    unitSystem: google.maps.UnitSystem.METRIC,
                };

                directionsService.route(fullTripRequest, (response, status) => {

                    if (status !== 'OK') {
                        loadingIndicator.classList.add('hidden');
                        let errorMessage = "Could not calculate the full route. Status: " + status;
                        if (status === 'ZERO_RESULTS') {
                            errorMessage = "No route found. Please check all locations are valid.";
                        } 
                        displayMessage(errorMessage, 'error');
                        resultSection.classList.remove('hidden');
                        return;
                    }

                    let totalDistanceMeters = 0;
                    let totalDurationSeconds = 0;

                    response.routes[0].legs.forEach(leg => {
                        totalDistanceMeters += leg.distance.value;
                        totalDurationSeconds += leg.duration.value;
                    });

                    const isRoundTrip = roundTripToggle.checked;
                    
                    if (isRoundTrip) {
                        // Calculate return journey if round trip is selected
                        calculateReturnTrip(origin, destination, totalDistanceMeters, totalDurationSeconds, fuelEfficiency, fuelPrice, distanceToFirstStopMeters);
                    } else {
                        // Finalize calculation for one-way trip
                        finalizeTripCalculation(totalDistanceMeters, totalDurationSeconds, fuelEfficiency, fuelPrice, distanceToFirstStopMeters);
                    }
                });
            });
        }

        /**
         * Helper function to format duration from seconds to a readable string (e.g., "1 day 5 hr 30 min").
         */
        function formatDuration(seconds) {
            const days = Math.floor(seconds / (3600 * 24));
            seconds -= days * 3600 * 24;
            const hours = Math.floor(seconds / 3600);
            seconds -= hours * 3600;
            const minutes = Math.floor(seconds / 60);

            let parts = [];
            if (days > 0) parts.push(days + ' day' + (days > 1 ? 's' : ''));
            if (hours > 0) parts.push(hours + ' hr');
            if (minutes > 0) parts.push(minutes + ' min');

            return parts.length > 0 ? parts.join(' ') : 'Less than a minute';
        }

        // --- Event listeners ---
        addPickupButton.addEventListener('click', addPickup);
        addDropoffButton.addEventListener('click', addDropoff);
        calculateButton.addEventListener('click', calculateTripCost);
        currentLocationButton.addEventListener('click', setCurrentLocation); 
        
        // Listener for the interactive weather button (toggle the active class for the tooltip)
        weatherOriginDetails.addEventListener('click', () => {
            weatherOriginDetails.classList.toggle('active');
        });
        
        // Add weather fetch on blur for the Origin input
        originInput.addEventListener('blur', () => {
             if (originInput.value.trim()) {
                fetchWeather(originInput.value, weatherOriginDetails);
            }
        });


        // Load Google Maps API script dynamically
        function loadMapsScript() {
            // Check if API_KEY is available from config.js (or globally if executed in a sandbox)
            if (typeof API_KEY === 'undefined' || API_KEY === "YOUR_GOOGLE_MAPS_API_KEY" || API_KEY === "") {
                displayMessage("Google Maps API Key missing or unset in config.js. Please update the key and try reloading.", 'error');
                return;
            }

            const script = document.createElement('script');
            // The callback parameter 'initAutocomplete' must match the function name defined above
            script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places,geometry&callback=initAutocomplete`;
            script.async = true;
            script.onerror = () => {
                displayMessage("Error loading the Google Maps API script. Check your API key or network connection.", 'error');
            };
            document.head.appendChild(script);
        }

        // Start loading the script when the window loads
        window.onload = loadMapsScript;

    </script>
</body>
</html>